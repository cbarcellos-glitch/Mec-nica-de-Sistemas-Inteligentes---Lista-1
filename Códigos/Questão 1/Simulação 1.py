# -*- coding: utf-8 -*-
"""Lista 1 Sistemas Inteligentes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mlR0l13s5XTUkI0tnTPqYCdgse3TytG0

#Quetão 1
"""

import numpy as np
import matplotlib.pyplot as plt

# Parâmetros do sistema
zeta = 0.5       # Fator de amortecimento
omega_n = 1.0    # Frequência natural (rad/s)
gamma = 1.0      # Amplitude da força externa
omega = 2.0      # Frequência de forçamento (rad/s)

# Condições iniciais
x0 = 1.0         # Posição inicial
v0 = 0.0         # Velocidade inicial

# Parâmetros de tempo
t0 = 0.0         # Tempo inicial
tf = 50.0        # Tempo final
h = 0.001         # Passo de tempo inicial (para RK4)
tol = 1e-6       # Tolerância para DOPRI45

def oscilador_forcado(t, y, zeta, omega_n, gamma, omega):
    """
    Sistema de EDOs para o oscilador harmônico forçado e amortecido
    y = [x, v]
    """
    x, v = y
    dxdt = v
    dvdt = -2*zeta*omega_n*v - omega_n**2*x + gamma*np.sin(omega*t)
    return np.array([dxdt, dvdt])

def runge_kutta4(f, t, y, h, *args):
    """
    Implementação do método de Runge-Kutta de 4ª ordem
    """
    k1 = f(t, y, *args)
    k2 = f(t + h/2, y + h/2 * k1, *args)
    k3 = f(t + h/2, y + h/2 * k2, *args)
    k4 = f(t + h, y + h * k3, *args)

    return y + h/6 * (k1 + 2*k2 + 2*k3 + k4)

def dormand_prince45(f, t, y, h, *args):
    """
    Implementação do método Dormand-Prince (DOPRI45)
    Retorna a próxima estimativa e o erro estimado
    """
    # Coeficientes do método DOPRI5
    a2 = 1/5
    a3 = 3/10
    a4 = 4/5
    a5 = 8/9
    a6 = 1
    a7 = 1

    b21 = 1/5

    b31 = 3/40
    b32 = 9/40

    b41 = 44/45
    b42 = -56/15
    b43 = 32/9

    b51 = 19372/6561
    b52 = -25360/2187
    b53 = 64448/6561
    b54 = -212/729

    b61 = 9017/3168
    b62 = -355/33
    b63 = 46732/5247
    b64 = 49/176
    b65 = -5103/18656

    b71 = 35/384
    b72 = 0
    b73 = 500/1113
    b74 = 125/192
    b75 = -2187/6784
    b76 = 11/84

    # Coeficientes para estimativa de erro (ordem 4)
    e1 = 71/57600
    e2 = 0
    e3 = -71/16695
    e4 = 71/1920
    e5 = -17253/339200
    e6 = 22/525
    e7 = -1/40

    k1 = f(t, y, *args)
    k2 = f(t + a2*h, y + h*(b21*k1), *args)
    k3 = f(t + a3*h, y + h*(b31*k1 + b32*k2), *args)
    k4 = f(t + a4*h, y + h*(b41*k1 + b42*k2 + b43*k3), *args)
    k5 = f(t + a5*h, y + h*(b51*k1 + b52*k2 + b53*k3 + b54*k4), *args)
    k6 = f(t + a6*h, y + h*(b61*k1 + b62*k2 + b63*k3 + b64*k4 + b65*k5), *args)
    k7 = f(t + a7*h, y + h*(b71*k1 + b72*k2 + b73*k3 + b74*k4 + b75*k5 + b76*k6), *args)

    # Próximo passo (ordem 5)
    y_next = y + h*(b71*k1 + b73*k3 + b74*k4 + b75*k5 + b76*k6)

    # Estimativa de erro (diferença entre ordens 5 e 4)
    error = h*(e1*k1 + e3*k3 + e4*k4 + e5*k5 + e6*k6 + e7*k7)

    return y_next, error

def solucao_analitica(t, zeta, omega_n, gamma, omega, x0, v0):
    """
    Solução analítica para o oscilador harmônico forçado e amortecido
    Retorna posição e velocidade
    """
    # Frequência amortecida
    omega_d = omega_n * np.sqrt(1 - zeta**2)

    # Solução homogênea (transiente)
    if zeta < 1:  # Subamortecido
        A = x0
        B = (v0 + zeta*omega_n*x0) / omega_d
        x_hom = np.exp(-zeta*omega_n*t) * (A*np.cos(omega_d*t) + B*np.sin(omega_d*t))
        v_hom = np.exp(-zeta*omega_n*t) * (-zeta*omega_n*(A*np.cos(omega_d*t) + B*np.sin(omega_d*t)) +
                                           omega_d*(-A*np.sin(omega_d*t) + B*np.cos(omega_d*t)))
    elif zeta == 1:  # Criticamente amortecido
        A = x0
        B = v0 + omega_n*x0
        x_hom = np.exp(-omega_n*t) * (A + B*t)
        v_hom = np.exp(-omega_n*t) * (B - omega_n*(A + B*t))
    else:  # Superamortecido
        alpha = omega_n * np.sqrt(zeta**2 - 1)
        A = (v0 + (zeta + np.sqrt(zeta**2 - 1))*omega_n*x0) / (2*alpha)
        B = (-v0 - (zeta - np.sqrt(zeta**2 - 1))*omega_n*x0) / (2*alpha)
        x_hom = np.exp(-zeta*omega_n*t) * (A*np.exp(alpha*t) + B*np.exp(-alpha*t))
        v_hom = np.exp(-zeta*omega_n*t) * ((-zeta*omega_n)*(A*np.exp(alpha*t) + B*np.exp(-alpha*t)) +
                                          alpha*(A*np.exp(alpha*t) - B*np.exp(-alpha*t)))

    # Solução particular (regime permanente)
    delta = np.arctan2(2*zeta*omega_n*omega, omega_n**2 - omega**2)
    X = gamma / np.sqrt((omega_n**2 - omega**2)**2 + (2*zeta*omega_n*omega)**2)
    x_par = X * np.sin(omega*t - delta)
    v_par = X * omega * np.cos(omega*t - delta)

    return x_hom + x_par, v_hom + v_par

def resolver_rk4(f, t0, tf, h, y0, *args):
    """Resolve o sistema usando RK4 com passo fixo e retorna também informações sobre os passos"""
    num_steps = int((tf - t0) / h) + 1
    t_values = np.linspace(t0, tf, num_steps)
    y_values = np.zeros((num_steps, len(y0)))
    y_values[0] = y0

    for i in range(1, num_steps):
        y_values[i] = runge_kutta4(f, t_values[i-1], y_values[i-1], h, *args)

    # Informações sobre os passos (constantes para RK4)
    steps = np.full(num_steps-1, h)
    return t_values, y_values, steps

def resolver_dopri45(f, t0, tf, h_init, y0, tol, *args):
    """Resolve o sistema usando DOPRI45 com passo adaptativo e retorna informações sobre os passos"""
    t_values = [t0]
    y_values = [y0.copy()]
    steps = []  # Armazenará os passos usados

    # Parâmetros para controle adaptativo
    h_min = 1e-6
    h_max = 0.1
    safety = 0.9
    beta = 0.04
    alpha = 0.2 - beta*0.75

    t_current = t0
    h_current = h_init
    y_current = y0.copy()

    while t_current < tf:
        if t_current + h_current > tf:
            h_current = tf - t_current

        y_next, error = dormand_prince45(f, t_current, y_current, h_current, *args)

        # Armazena o passo usado
        steps.append(h_current)

        # Estimativa do erro
        error_norm = np.linalg.norm(error)
        scale = np.abs(y_current) + np.abs(h_current * f(t_current, y_current, *args))
        error_ratio = error_norm / (tol * np.sqrt(len(y_current)))

        # Aceita o passo se o erro for pequeno o suficiente
        if error_ratio <= 1.0:
            t_current += h_current
            y_current = y_next
            t_values.append(t_current)
            y_values.append(y_current.copy())

            # Ajusta o passo para o próximo intervalo
            if error_ratio == 0.0:
                factor = 5.0
            else:
                factor = safety * (1/error_ratio)**alpha

            h_current *= min(factor, 5.0)
            h_current = min(h_current, h_max)

        else:
            # Rejeita o passo e tenta com um passo menor
            factor = max(safety * (1/error_ratio)**beta, 0.1)
            h_current *= factor
            h_current = max(h_current, h_min)

    return np.array(t_values), np.array(y_values), np.array(steps)

# Resolver com todos os métodos
t_rk4, y_rk4, steps_rk4 = resolver_rk4(oscilador_forcado, t0, tf, h, np.array([x0, v0]),
                                     zeta, omega_n, gamma, omega)
x_rk4 = y_rk4[:, 0]
v_rk4 = y_rk4[:, 1]

t_dopri, y_dopri, steps_dopri = resolver_dopri45(oscilador_forcado, t0, tf, h, np.array([x0, v0]), tol,
                                                zeta, omega_n, gamma, omega)
x_dopri = y_dopri[:, 0]
v_dopri = y_dopri[:, 1]

# Solução analítica
x_analitico, v_analitico = solucao_analitica(t_dopri, zeta, omega_n, gamma, omega, x0, v0)

# Análise dos passos
print("\nAnálise dos passos:")
print(f"RK4: Passo fixo de {h:.4f}, total de {len(steps_rk4)} passos")
print(f"DOPRI45: Mínimo = {steps_dopri.min():.4f}, Máximo = {steps_dopri.max():.4f}, Médio = {steps_dopri.mean():.4f}")
print(f"DOPRI45: Total de {len(steps_dopri)} passos ({(len(steps_rk4)/len(steps_dopri)):.1f}x mais que RK4)")

# Gráfico: Erros
plt.figure(figsize=(14, 6))
x_rk4_interp = np.interp(t_dopri, t_rk4, x_rk4)
v_rk4_interp = np.interp(t_dopri, t_rk4, v_rk4)

erro_x_rk4 = np.abs(x_rk4_interp - x_analitico)
erro_x_dopri = np.abs(x_dopri - x_analitico)
erro_v_rk4 = np.abs(v_rk4_interp - v_analitico)
erro_v_dopri = np.abs(v_dopri - v_analitico)

plt.semilogy(t_dopri, erro_x_dopri, 'g', label='Erro Posição DOPRI45', linewidth=1.5)
plt.semilogy(t_dopri, erro_x_rk4, 'b', label='Erro Posição RK4', linewidth=1.5)
plt.xlabel('Tempo (s)')
plt.ylabel('Erro absoluto')
plt.title('Comparação dos Erros (escala logarítmica)')
plt.legend()
plt.grid(True)

# Gráfico 1
plt.figure(figsize=(14, 6))
plt.plot(t_rk4, x_rk4, 'b-', label='RK4', linewidth=1.5)
plt.plot(t_dopri, x_analitico, 'r:', label='Analítica', linewidth=2)
plt.xlabel('Tempo (s)')
plt.ylabel('Posição (x)')
plt.title('Comparação das Soluções - Posição')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# Gráfico 2
plt.figure(figsize=(14, 6))
plt.plot(t_dopri, x_dopri, 'g', label='DOPRI45', linewidth=1.5)
plt.plot(t_dopri, x_analitico, 'r:', label='Analítica', linewidth=2)
plt.xlabel('Tempo (s)')
plt.ylabel('Posição (x)')
plt.title('Comparação das Soluções - Posição')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()